-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Github at
--   <a>https://github.com/michaeljklein/push-pull-inst-proto#readme</a>
@package push-pull-inst-proto
@version 0.1.0.0

module Lib
class (Functor f, Functor g) => Push f g
part :: Push f g => f (g a) -> f (f (g a))
pver :: Push f g => f (f (g a)) -> f (g (f a))

-- | <pre>
--   <a>push</a> = <a>pver</a> . <a>part</a>
--   </pre>
push :: Push f g => f (g a) -> f (g (f a))
class Pull f g
draw :: Pull f g => f (g (f a)) -> f (f (g a))
bond :: Pull f g => f (f (g a)) -> f (g a)

-- | <pre>
--   <a>pull</a> = <a>bond</a> . <a>draw</a>
--   </pre>
pull :: Pull f g => f (g (f a)) -> f (g a)
newtype (:~) a b
Ty :: a -> (:~) a b
[getTy] :: (:~) a b -> a
data Cat a
[Obj] :: a -> Cat (a :~ Cat a)
[Mor] :: (a -> b) -> Cat ((a -> b) :~ (Cat a -> Cat b))
[Comp] :: Cat ((b -> c) :~ (Cat b -> Cat c)) -> Cat ((a -> b) :~ (Cat a -> Cat b)) -> Cat ((a -> c) :~ (Cat a -> Cat c))
[Id] :: Cat ((a -> a) :~ (Cat a -> Cat a))
fib0 :: (Num p, Num a, Eq a) => a -> p
fib1 :: (Ord a, Num p, Num a) => a -> p

-- | fib1 is a source transformation of fib0, each having exponential
--   complexity in n when interpreted naively, but they're the standard
--   definition of the fibonacci numbers.
--   
--   Compare the timing of fib0 with fib2:
--   
--   <pre>
--   位&gt; fib0 <a>$</a> [0..30]
--   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040]
--   (8.97 secs, 2,413,020,008 bytes)
--   
--   位&gt; fib2 <a>$</a> [0..30]
--   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040]
--   (0.01 secs, 628,816 bytes)
--   </pre>
--   
--   In fact, fib2 stays fast up to pretty large values:
--   
--   <pre>
--   位&gt; length $ fib2 <a>$</a> [0..10^8]
--   100000001
--   (3.52 secs, 16,000,374,552 bytes)
--   
--   位&gt; length $ fib2 <a>$</a> [0..10^9]
--   1000000001
--   (35.85 secs, 160,000,375,376 bytes)
--   </pre>
--   
--   Suggesting that it's roughly <tt>O(n)</tt> as we'd expect.
fib2 :: Integer -> Integer
fib3 :: (Num d, Integral a) => a -> d

-- | One implementation of the collatz function
collatz0 :: (Integral a1, Num a2) => a1 -> a2

-- | Another implementation of the collatz function, using case and
--   <a>mod</a> instead of <a>even</a>
collatz1 :: (Integral a1, Num a2) => a1 -> a2

-- | <a>collatz1</a> using <tt><a>divMod</a> n 4</tt> to expand the number
--   of cases covered in a single <tt>case</tt> statement
collatz2 :: (Integral a1, Num a2) => a1 -> a2

-- | Drop all subtrees whose root is <a>Nothing</a>
noNothing :: Tree (Maybe a) -> Tree (Maybe a)

-- | Another implementation of <a>noNothing</a>, this one specialized to
--   precomposition with <a>Tree</a>
noNothing2 :: Tree (Tree (Maybe a)) -> Tree (Tree (Maybe a))

-- | Map over the top-level <a>Forest</a> in a <a>Tree</a>
forestMap :: (Forest a -> Forest a) -> Tree a -> Tree a

-- | Recursively filter a Tree by values
filterTree :: (a -> Bool) -> a -> Tree a -> Tree a

-- | Is the input <a>Pure</a>?
isPure :: Free f a -> Bool

-- | f'(expr)
quote :: Push f g => (f (f (g a)) -> f (f (g b))) -> f (g a) -> f (g (f b))

-- | f`(expr)
unquote :: Pull f g => (f (f (g a)) -> f (f (g b))) -> f (g (f a)) -> f (g b)
someFunc :: IO ()
instance GHC.Base.Functor g => Lib.Push GHC.Types.IO g
instance Lib.Push [] GHC.Base.Maybe
instance Lib.Push Data.List.NonEmpty.NonEmpty GHC.Base.Maybe
instance Lib.Push Data.Tree.Tree GHC.Base.Maybe
instance GHC.Base.Applicative g => Lib.Push [] (Control.Monad.Free.Free g)
instance GHC.Base.Alternative g => Lib.Push [] (Control.Comonad.Cofree.Cofree g)
